% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/convert_to.R
\name{convert_to}
\alias{convert_to}
\alias{convert_to.character}
\alias{convert_to.numeric}
\alias{convert_to.Duration}
\alias{convert_to.Period}
\alias{convert_to.difftime}
\alias{convert_to.hms}
\alias{convert_to.Date}
\alias{convert_to.POSIXt}
\alias{convert_to.Interval}
\alias{convert_to.data.frame}
\alias{convert_to_tu}
\alias{convert_to_ut}
\alias{convert_to_tt}
\alias{convert_to_uu}
\alias{convert_to_pt}
\alias{convert_to_pu}
\title{Convert a R object to another}
\usage{
convert_to(x, class, ..., quiet = FALSE)

\method{convert_to}{character}(
  x,
  class,
  ...,
  orders = NULL,
  tz = "UTC",
  input_unit = NULL,
  output_unit = NULL,
  month_length = lubridate::dmonths(),
  year_length = lubridate::dyears(),
  ignore_date = TRUE,
  close_round = TRUE,
  quiet = FALSE
)

\method{convert_to}{numeric}(
  x,
  class,
  ...,
  orders = NULL,
  tz = "UTC",
  input_unit = NULL,
  output_unit = NULL,
  month_length = lubridate::dmonths(),
  year_length = lubridate::dyears(),
  ignore_date = TRUE,
  close_round = TRUE,
  quiet = FALSE
)

\method{convert_to}{Duration}(
  x,
  class,
  ...,
  tz = "UTC",
  output_unit = NULL,
  month_length = lubridate::dmonths(),
  year_length = lubridate::dyears(),
  close_round = TRUE,
  quiet = FALSE
)

\method{convert_to}{Period}(
  x,
  class,
  ...,
  tz = "UTC",
  output_unit = NULL,
  month_length = lubridate::dmonths(),
  year_length = lubridate::dyears(),
  close_round = TRUE,
  quiet = FALSE
)

\method{convert_to}{difftime}(
  x,
  class,
  ...,
  tz = "UTC",
  output_unit = NULL,
  month_length = lubridate::dmonths(),
  year_length = lubridate::dyears(),
  close_round = TRUE,
  quiet = FALSE
)

\method{convert_to}{hms}(
  x,
  class,
  ...,
  tz = "UTC",
  output_unit = NULL,
  month_length = lubridate::dmonths(),
  year_length = lubridate::dyears(),
  close_round = TRUE,
  quiet = FALSE
)

\method{convert_to}{Date}(
  x,
  class,
  ...,
  tz = "UTC",
  output_unit = NULL,
  month_length = lubridate::dmonths(),
  year_length = lubridate::dyears(),
  close_round = TRUE,
  quiet = FALSE
)

\method{convert_to}{POSIXt}(
  x,
  class,
  ...,
  tz = "UTC",
  output_unit = NULL,
  month_length = lubridate::dmonths(),
  year_length = lubridate::dyears(),
  ignore_date = TRUE,
  close_round = TRUE,
  quiet = FALSE
)

\method{convert_to}{Interval}(
  x,
  class,
  ...,
  tz = "UTC",
  output_unit = NULL,
  month_length = lubridate::dmonths(),
  year_length = lubridate::dyears(),
  close_round = TRUE,
  quiet = FALSE
)

\method{convert_to}{data.frame}(
  x,
  class,
  ...,
  cols = NULL,
  where = NULL,
  orders = NULL,
  tz = "UTC",
  input_unit = NULL,
  output_unit = NULL,
  month_length = lubridate::dmonths(),
  year_length = lubridate::dyears(),
  close_round = TRUE,
  quiet = FALSE
)

convert_to_tu(x, output_unit, ...)

convert_to_ut(x, class, input_unit, ...)

convert_to_tt(x, class, ...)

convert_to_uu(x, input_unit, output_unit, ...)

convert_to_pt(x, class, orders, ...)

convert_to_pu(x, orders, output_unit, ...)
}
\arguments{
\item{x}{Any R object, provided that it has an assigned method.}

\item{class}{A string indicating the class of the output.}

\item{...}{Additional arguments to be passed to or from methods.}

\item{quiet}{(optional) a logical value indicating if warnings or messages
must be suppressed (default: \code{FALSE}).}

\item{orders}{(optional) a character vector of date/time formats to parse a
\code{x} value of class \code{character} or \code{numeric}.}

\item{tz}{(optional) a string indicating the time zone with which to
convert/parse \code{x} (defaul: \code{"UTC"}).}

\item{input_unit}{(optional) a string indicating the unit of \code{x}.}

\item{output_unit}{(optional) a string indicating the desire output unit.}

\item{month_length}{(optional) a \code{duration} object or a non negative numeric
value with the number of seconds equivalent to the month length (default:
\code{lubridate::dmonths()}, which is equivalent to 30.4375 days).}

\item{year_length}{(optional) a \code{duration} object or a non negative numeric
value with the number of seconds equivalent to the year length (default:
\code{lubridate::dyears()}, which is equivalent to 365.25 days).}

\item{ignore_date}{(optional) a logical value indicating if dates must be
ignored from \code{Date} or \code{POSIXt} objects when converting they to \code{numeric}.}

\item{close_round}{(optional) a logical value indicating if numbers with
decimals starting with five leading 0s or 9s must be rounded
(\emph{e.g.} 1.99999) (default: \code{TRUE}).}

\item{cols}{(optional) a character vector indicating the column names in \code{x}
to transform (default: \code{NULL}).}

\item{where}{(optional) a function to apply in a \code{\link[tidyselect:where]{tidyselect::where()}} call
(default: \code{NULL}).}
}
\value{
A R object of the indicated class.
}
\description{
\ifelse{html}{\out{<a href='https://www.tidyverse.org/lifecycle/#experimental'><img src='figures/lifecycle-experimental.svg' alt='Experimental lifecycle'></a>}}{\strong{Experimental}}

\code{convert_to} converts a R object to another object of a predefined class. Its
mission is to facilitate conversions between any kind of R object in a
simple and fast way.

This function also supports date/time parsing and value transformations.
Check Details section to learn more.

For a complete picture about how to convert your MCTQ data, see
\code{vignette("converting_data", package = "mctq")}.
}
\details{
\code{convert_to} was designed to be a simple to use function with powerful
applications. However, please note that it may not work for all cases.
Test it first before applying it to large datasets.

To learn more about how to handle date and time objects, check chapter "Dates
and Times" from Wickham and Grolemund (\href{https://r4ds.had.co.nz}{n.d.}) and
chapter "Technical Representation of Data" from Loo and Jonge
(\href{https://bit.ly/3pVuUdt}{2018}).
\subsection{Wrappers}{

\code{convert_to} have some wrappers functions for convenience.
\itemize{
\item \code{convert_to_tu} help make conversions from date/time objects to units.
\item \code{convert_to_ut} help make conversions from units to date/time objects.
\item \code{convert_to_tt} help make conversions from date/time objects to other
date/time objects.
\item \code{convert_to_uu} help make conversions from unit to other units.
\item \code{convert_to_pt} help make conversions from \code{character} or \code{numeric} objects
to date/time objects.
\item \code{convert_to_pu} help make conversions from \code{character} or \code{numeric} objects
to units.
}
}

\subsection{\code{class} argument}{

The \code{class} argument indicates the desired class of the output object . It
accepts the following values: \code{"character"}, \code{"integer"}, \code{"double"},
\code{"numeric"}, \code{"Duration"}, \code{"Period"}, \code{"difftime"}, \code{"hms"}, \code{"Date"},
\code{"POSIXct"}, and \code{"POSIXlt"} (case insensitive).
}

\subsection{\code{orders} argument}{

\code{orders} is an optional argument to indicate date/time formats for
parsing \code{character} or \code{numeric} objects. This parsing is mainly
based on \code{\link[lubridate:parse_date_time]{lubridate::parse_date_time()}}, please check it documentation
to set the right formats for your input.
}

\subsection{\code{input_unit} and \code{output_unit} arguments}{

To be able to convert date/time objects and \code{numeric} objects to decimal
time, radians, or degrees, \code{convert_to} need to know the unit of \code{x} and the
output unit. Conversions of date/time objects only need the latter.

Valid values for this two arguments are:
\itemize{
\item \code{"S"}: for decimal seconds.
\item \code{"M"}: for decimal minutes.
\item \code{"H"}: for decimal hours.
\item \code{"d"}: for decimal days.
\item \code{"W"}: for decimal weeks.
\item \code{"m"}: for decimal months.
\item \code{"y"}: for decimal years.
\item \code{"date_decimal"}: for decimal dates.
\item \code{"rad"}: for radians.
\item \code{"deg"}: for degrees.
}
}

\subsection{\code{tz} argument}{

Time zones (tz) are used only if \code{class} is set to \code{"Date"}, \code{"POSIXct"}, or
\code{"POSIXlt"}. See \link[base:timezones]{base::timezones} to know more about time zone values
(default: \code{"UTC"}).
}

\subsection{Parsing limitations}{

\code{convert_to} uses \code{\link[lubridate:parse_date_time]{lubridate::parse_date_time()}} to parse \code{character} and
\code{numeric} objects to date/time. Since parse_date_time() outputs a \code{POSIXt}
object, \code{character} and \code{numeric} inputs cannot have time values equal or
greater than 24 hours.

That limits the set of \code{convert_to} applications (\emph{e.g} when you want to
parse a \code{character} to a \code{duration} object of 35 minutes and 30 seconds). To
get around this, some exceptions were made to orders \strong{equal} to \code{"H"},
\code{"M"}, \code{"S"}, \code{HM}, or \code{HMS}. For \code{HM} and \code{HMS} exceptions, minutes and
seconds are limited to \verb{[0-59]}, and, when hours exceeds 2 digits, a \code{:} must
be allocated between hours and minutes.
}

\subsection{Converting columns of a data frame}{

\code{convert_to} also allow conversions of data frame variables. This is made
with the help of \code{\link[dplyr:mutate]{dplyr::mutate()}}.

Operations with data frames are only column-wise and can be made by
selecting individual columns (using the \code{col} argument) or group of columns
(by applying a flag function (\emph{e.g} \code{is.numeric}) in the \code{where} argument).
\itemize{
\item When \code{class = "character"}
}

\code{convert_to} will return a \code{\link[base:character]{base::as.character()}} output if \code{class} is set to
\code{"character"}. When \code{x} is parsed for date/time, and there's no
indication of year, \code{convert_to} will return only a character string with a
\code{hms} time.
}

\subsection{Different outputs}{

Your output can change according to your settings. Here are some examples.
\itemize{
\item When \code{class = "character"}
}

\code{convert_to} will return a \code{\link[base:character]{base::as.character()}} output if \code{class} is set to
\code{"character"}. When \code{x} is parsed for date/time, and there's no
indication of year, \code{convert_to} will return only a character string with a
\code{hms} time.

You can also parse a \code{character} object and transform it direct to an unit.
See Examples section to know how.
\itemize{
\item When \code{class = "numeric"}
}

\code{convert_to} will return a \code{\link[base:numeric]{base::as.numeric()}} output if \code{class} is set to
\code{"numeric"}. For dates or date-time objects, the output will be the total of
seconds from the UNIX origin (\verb{1970-01-01 00:00:00 UTC}) (See \href{https://en.wikipedia.org/wiki/Unix_time}{Unix time} to know more). For time
values, the output will be the total of seconds.

The output \code{class = "numeric"} can also be different if \code{input_unit} and
\code{output_unit} are assigned.
\itemize{
\item \code{Interval} objects
}

\code{Interval} objects are treated like \code{difftime} objects. That is,
\code{Interval} objects will be converted to the time difference of the interval.
}

\subsection{Round-off errors}{

This function is not optimized to deal with
\href{https://en.wikipedia.org/wiki/Round-off_error}{round-off errors}.
}

\subsection{Year and month lengths}{

The length of months and years can vary. For example, March have 31 days,
while April have have 30. Due to leap years, the same can be said to year
lengths.

To address this problem, \code{convert_to} use as default the mean of
possible values for months and years, used to calculate month and year
durations in the lubridate package (see: \code{\link[lubridate:duration]{lubridate::dmonths()}} and
\code{\link[lubridate:duration]{lubridate::dyears()}}). If you like, you can reset this assigning other
values to \code{month_length} and \code{year_length}.

\code{month_length} and \code{year_length} values must be assigned with the number of
seconds equivalent to unit duration. You can also assign a lubridate duration
object (see \code{\link[lubridate:duration]{lubridate::duration()}}) if you like.
}

\subsection{Decimal dates}{

\code{convert_to} can be used as a wrapper to \code{\link[lubridate:decimal_date]{lubridate::decimal_date()}}
by creating decimal dates that can be used on \code{\link[lubridate:date_decimal]{lubridate::date_decimal()}}.

Decimal dates are a kind of decimal time where the year corresponds to the
integer part of the value. The months, days, hours, minutes, and seconds
elements are picked so the date-time will represent the fraction of the year
expressed by decimal.

Beware that decimal dates are not very precise! It cannot be used as a way
to store time data.
}
}
\examples{
## __ Conversion from date/time objects to units __
convert_to(lubridate::dhours(), "numeric", output_unit = "M")
#> [1] 60 # Expected
convert_to(lubridate::days(), "numeric", output_unit = "rad")
#> [1] 6.283185 # Expected
x <- lubridate::as_datetime("1985-10-20 12:00:00")
convert_to(x, "numeric", output_unit = "d")
#> [1] 0.5 # Expected
x <- lubridate::as_datetime("1985-10-20 12:00:00")
convert_to(x, "numeric", output_unit = "d", ignore_date = FALSE)
#> [1] 5771.5 # Expected (days since UNIX origin)
convert_to(hms::parse_hm("15:45:00"), "numeric", output_unit = "H")
#> [1] 15.75 # Expected
convert_to_tu(hms::parse_hm("15:45:00"), "H") # Wrapper function
#> [1] 15.75 # Expected

## __ Conversion from units to date/time objects __
convert_to(360, "period", input_unit = "deg")
#> [1] "1d 0H 0M 0S" # Expected
convert_to(6.5, "posixct", input_unit = "H")
#> [1] "1970-01-01 06:30:00 UTC" # Expected
convert_to(365.25, "hms", input_unit = "d")
#> 8766:00:00 # Expected
convert_to(1, "posixlt", input_unit = "W")
#> [1] "1970-01-08 UTC" # Expected
convert_to(1.308997, "duration", input_unit = "rad")
#> [1] "18000s (~5 hours)" # Expected
convert_to_ut(1.308997, "duration", "rad") # Wrapper function
#> [1] "18000s (~5 hours)" # Expected

## __ Conversion between date/time objects __
convert_to(lubridate::duration(120), "hms")
#> 00:02:00 # Expected
convert_to(hms::as_hms("13:45:05"), "POSIXct")
#> [1] "1970-01-01 13:45:05 UTC" # Expected
convert_to(lubridate::period(60), "POSIXct")
#> [1] "1970-01-01 00:01:00 UTC" # Expected
convert_to(lubridate::as_date("1765-10-05"), "POSIXct")
#> [1] "1765-10-05 UTC" # Expected
x <- lubridate::ymd_hms("2020-01-01 12:31:05", tz = "EST")
convert_to(x, "POSIXct")
#> [1] "2020-01-01 12:31:05 UTC" # Expected
convert_to_tt(x, "POSIXct") # Wrapper function
#> [1] "2020-01-01 12:31:05 UTC" # Expected

## __ Conversion between units __
convert_to(1.308997, "numeric", input_unit = "rad", output_unit = "H")
#> [1] 5 # Expected
convert_to(60, "numeric", input_unit = "deg", output_unit = "rad")
#> [1] 1.047198 # Expected
convert_to(1, "numeric", input_unit = "m", output_unit = "y")
#> [1] 0.08333333 # Expected
convert_to(0.2617994, "numeric", input_unit = "rad", output_unit = "H")
#> [1] 1 # Expected
convert_to(40, "numeric", input_unit = "d", output_unit = "deg")
#> [1] 14400 # Expected
convert_to_uu(40, "d", "deg") # Wrapper function
#> [1] 14400 # Expected

## __ Conversion from character or numeric objects to date/time objects __
convert_to("19:55:17", "duration", orders = "HMS")
#> [1] "71717s (~19.92 hours)" # Expected
convert_to("21:00", "Period", orders = "HM")
#> [1] "21H 0M 0S" # Expected
convert_to(1, "difftime", orders = "H")
#> Time difference of 3600 secs # Expected
convert_to("10:00 PM", "hms", orders = "IMp")
#> 22:00:00 # Expected
convert_to("2020-01-01 10:00:00", "Date", orders = "ymd HMS")
#> [1] "2020-01-01" # Expected
convert_to(13, "POSIXct", orders = "H")
#> [1] "1970-01-01 13:00:00 UTC" # Expected
convert_to("2020-01-01 12:31:05", "POSIXct", orders = "ymd HMS", tz = "EST")
#> [1] "2020-01-01 12:31:05 EST" # Expected
convert_to("03/07/1982 13:00", "POSIXlt", orders = "dmy HM")
#> [1] "1982-07-03 13:00:00 UTC" # Expected
convert_to_pt("03/07/1982 13:00", "POSIXlt", "dmy HM") # Wrapper function
#> [1] "1982-07-03 13:00:00 UTC" # Expected

## __ Conversion from character or numeric objects to units __
convert_to("0145", "numeric", orders = "HM", output_unit = "M")
#> [1] 105 # Expected
convert_to(45, "numeric", orders = "M", output_unit = "H")
#> [1] 0.75 # Expected
convert_to(4500, "numeric", orders = "HM", output_unit = "d")
#> [1] 1.875 # Expected
convert_to("2020-03-15 02", "numeric", orders = "ymd H", output_unit = "H")
#> [1] 2 # Expected
convert_to("01:00", "numeric", orders = "HM", output_unit = "rad")
#> [1] 0.261799 # Expected
convert_to_pu("01:00", "HM", "rad") # Wrapper function
#> [1] 0.2617994 # Expected

## __ Conversion of columns of a data frame __
\dontrun{
out <- convert_to(datasets::mtcars, "posixct", cols = c("cyl", "carb"),
                  orders = "H")
head(out)

out <- convert_to(datasets::iris, "duration", where = is.numeric,
                  input_unit = "H")
head(out)
}
}
\references{
Van der Loo, M., & De Jonge, E. (2018).
\emph{Statistical data cleaning with applications in R}. Hooboken, NJ: John
Wiley & Sons. doi:
\href{http://dx.doi.org/10.1002/9781118897126}{10.1002/9781118897126}.

Wickham, H, & Grolemund. (n.d.). \emph{R for data science}. Sebastopol, CA:
O'Reilly Media. Retrieved from \url{https://r4ds.had.co.nz}.
}
\seealso{
Other utility functions: 
\code{\link{assign_date}()},
\code{\link{pretty_mctq}()},
\code{\link{qplot_walk}()},
\code{\link{random_mctq}()},
\code{\link{round_time}()},
\code{\link{shortest_interval}()},
\code{\link{sum_time}()}
}
\concept{utility functions}
