% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/assign_date.R
\name{assign_date}
\alias{assign_date}
\title{Assign dates to two sequential hour values}
\usage{
assign_date(
  start,
  end,
  ambiguity = 0,
  return = "list",
  start_name = deparse(substitute(start)),
  end_name = deparse(substitute(end))
)
}
\arguments{
\item{start, end}{A \code{hms} or \code{POSIXt} vector indicating the start or end
hour.}

\item{ambiguity}{(optional) A numeric value or \code{NA} that instruct
\code{assign_date()} on how to deal with ambiguities (see Details)
(default: \code{0}).}

\item{return}{(optional) A string indicating the type of output (see Details)
(default: "list").}

\item{start_name, end_name}{(optional) a string indicating a name associated
with the \code{start} and \code{end} argument.}
}
\value{
\itemize{
\item If \code{return = "list"}, a named list with \code{start} and \code{end} outputs;
\item If \verb{return = "start}, only the \code{start} output;
\item If \code{return = "end"}, only the \code{end} output.
}
}
\description{
\code{assign_date()} assign dates to two sequential hour values. It can facilitate
time arithmetic, locating time values, without date reference, on a
timeline.
}
\details{
\subsection{\code{ambiguity} argument}{

In cases when \code{start} is equal to \code{end}, there are two possibilities of
intervals between the two hours, which results in a ambiguity. That's
because \code{start} and \code{end} can be at the same point in time or they can
distance themselves by one day, as illustrated below.\preformatted{ start,end       start,end     start,end         start,end
   start            end            start            end
   10:00           10:00           10:00           10:00
-----|---------------|---------------|---------------|----->
    0h              0h              0h              0h
            24h             24h             24h
}

You must instruct \code{assign_date()} on how to deal with this problem if it
occurs. There are three options to choose.
\itemize{
\item \code{ambiguity = 0}: to consider the interval between \code{start} and \code{end} as 0
hours, \emph{i.e} \code{start} and \code{end} are located at the same point in time
(default);
\item \code{ambiguity = 24}: to consider the interval between \code{start} and \code{end} as 24
hours, \emph{i.e.} \code{start} and \code{end} distance themselves by one day;
\item \code{ambiguity = NA}: to disregard this cases, assigning \code{NA} as value.
}
}

\subsection{\code{return} argument}{

\code{assign_date()} can return three different outputs:
\itemize{
\item \code{return = "list"}: returns a \code{list} object with two named elements
corresponding to \code{start} and \code{end} output;
\item \code{return = "start"}: returns only the \code{start} output;
\item \code{return = "end"}: returns only the \code{end} output.
}
}

\subsection{\code{start_name} and \code{end_name} arguments}{

These arguments serve to instruct \code{assign_date()} on how to name the
list elements when \code{return == "list"}. As default, the function will name
this elements with the names of the variables assigned to \code{start} and \code{end}
arguments.

If the number of characters (nchar) of \code{start_name} or \code{end_name} are equal
or greater than 30, \code{assign_date()} will name the list elements as \code{start}
and \code{end}.
}

\subsection{\code{POSIXt} objects}{

\code{POSIXt} values passed as argument to \code{start} or \code{end} will be strip of their
dates. Only the hours will be considered.
}

\subsection{\code{NA} values}{

\code{assign_date()} will return \code{NA} if \code{start} or \code{end} are \code{NA}.
}
}
\examples{
## ** To return `start` and `end` outputs **
start <- hms::parse_hms("22:15:00")
end <- hms::parse_hms("00:00:00")
assign_date(start, end)
#> $start # Expected
#> [1] "0000-01-01 22:15:00 UTC"
#>
#> $end
#> [1] "0000-01-02 UTC"

## ** To return only the `start` output **
start <- lubridate::parse_date_time("01:10:00", "HMS")
end <- lubridate::parse_date_time("11:45:00", "HMS")
assign_date(start, end, return = "start")
#> [1] "0000-01-01 01:10:00 UTC" # Expected

## ** To assign a 24h interval to ambiguities **
start <- lubridate::as_datetime("1985-01-15 12:00:00")
end <- lubridate::as_datetime("2020-09-10 12:00:00")
assign_date(start, end, ambiguity = 24)
#> $start
#> [1] "0000-01-01 12:00:00 UTC"
#>
#> $end
#> [1] "0000-01-02 12:00:00 UTC"
}
\seealso{
Other Time arithmetic: 
\code{\link{shortest_interval}()}
}
\concept{Time arithmetic}
