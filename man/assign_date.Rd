% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/assign_date.R
\name{assign_date}
\alias{assign_date}
\title{Assign dates to two sequential hours}
\usage{
assign_date(
  start,
  end,
  return = "interval",
  ambiguity = 0,
  start_name = deparse(substitute(start)),
  end_name = deparse(substitute(end))
)
}
\arguments{
\item{start, end}{A \code{hms} or \code{POSIXt} vector indicating the start or end
hour.}

\item{return}{(optional) a string indicating the class of the output (see
Details) (default: \code{"interval"}).}

\item{ambiguity}{(optional) a \code{numeric} value to instruct \code{assign_date()} on
how to deal with ambiguities (see Details) (default: \code{0}).}

\item{start_name, end_name}{(optional) a string indicating a name associated
with the \code{start} and \code{end} argument.}
}
\value{
\itemize{
\item If \code{return = "interval"}, a \code{start}---\code{end} \code{interval} object.
\item If \code{return = "list"}, a named list with \code{start} and \code{end} outputs.
\item If \verb{return = "start}, only the \code{start} output.
\item If \code{return = "end"}, only the \code{end} output.
}
}
\description{
\ifelse{html}{\out{<a href='https://www.tidyverse.org/lifecycle/#maturing'><img src='figures/lifecycle-maturing.svg' alt='Maturing lifecycle'></a>}}{\strong{Maturing}}

\code{assign_date()} assign dates to two sequential hours. It can facilitate
time arithmetic by locating time values without date reference on a
timeline.
}
\details{
\subsection{Class requirements}{

The \code{mctq} package works with a set of object classes specially created to
hold time values. This classes can be found on \link[hms:hms-package]{hms::hms-package} and
\link[lubridate:lubridate-package]{lubridate::lubridate-package}. If your data do not conform to the object
classes required, you can use \code{\link[=convert]{convert()}} to convert it
(see \code{vignette("converting-data", package = "mctq")}).
}

\subsection{\code{ambiguity} argument}{

In cases when \code{start} is equal to \code{end}, there are two possibilities of
intervals between the two hours (ambiguity). That's because \code{start} and \code{end}
can be at the same point in time or they can distance themselves by one day,
as illustrated below.\preformatted{ start,end       start,end       start,end       start,end
   start            end            start            end
   10:00           10:00           10:00           10:00
-----|---------------|---------------|---------------|----->
    0h              0h              0h              0h
            24h             24h             24h
}

You must instruct \code{assign_date()} on how to deal with this problem if it
occurs. There are three options to choose.
\itemize{
\item \code{ambiguity = 0}: to consider the interval between \code{start} and \code{end} as 0
hours, \emph{i.e} \code{start} and \code{end} are located at the same point in time
(default).
\item \code{ambiguity = 24}: to consider the interval between \code{start} and \code{end} as 24
hours, \emph{i.e.} \code{start} and \code{end} distance themselves by one day.
\item \code{ambiguity = NA}: to disregard this cases, assigning \code{NA} as value.
}
}

\subsection{\code{return} argument}{

\code{assign_date()} can return different outputs:
\itemize{
\item \code{return = "interval"}: returns a \code{start}---\code{end} \code{interval} object.
\item \code{return = "list"}: returns a \code{list} object with two named elements
corresponding to \code{start} and \code{end} output.
\item \code{return = "start"}: returns only the \code{start} output.
\item \code{return = "end"}: returns only the \code{end} output.
}
}

\subsection{\code{start_name} and \code{end_name} arguments}{

These arguments serve to instruct \code{assign_date()} on how to name the
list elements when \code{return == "list"}. As default, the function will name
this elements with the names of the variables assigned to \code{start} and \code{end}
arguments.

If the number of characters (\code{nchar}) of \code{start_name} or \code{end_name} are equal
or greater than 30, \code{assign_date()} will name the list elements as \code{"start"}
and \code{"end"}.
}

\subsection{\code{POSIXt} objects}{

\code{POSIXt} values passed as argument to \code{start} or \code{end} will be strip of their
dates. Only the hours will be considered.
}

\subsection{\code{NA} values}{

\code{assign_date()} will return \code{NA} if \code{start} or \code{end} are \code{NA}.
}
}
\examples{
## __ Scalar example __
start <- hms::parse_hms("23:11:00")
end <- hms::parse_hms("05:30:00")
assign_date(start, end)
#> [1] 1970-01-01 23:11:00 UTC--1970-01-02 05:30:00 UTC # Expected

start <- hms::parse_hms("10:15:00")
end <- hms::parse_hms("13:25:00")
assign_date(start, end)
#> [1] 1970-01-01 10:15:00 UTC--1970-01-01 13:25:00 UTC # Expected

start <- hms::parse_hms("05:42:00")
end <- hms::as_hms(NA)
assign_date(start, end)
#> [1] NA--NA # Expected

## __ Vector example __
start <- c(hms::parse_hm("09:45"), hms::parse_hm("20:30"))
end <- c(hms::parse_hm("21:15"), hms::parse_hm("04:30"))
assign_date(start, end)
#> [1] 1970-01-01 09:45:00 UTC--1970-01-01 21:15:00 UTC # Expected
#> [2] 1970-01-01 20:30:00 UTC--1970-01-02 04:30:00 UTC # Expected

## __ To return `start` and `end` as interval (default)__
start <- hms::parse_hm("12:34")
end <- hms::parse_hm("01:25")
assign_date(start, end)
#> [1] 1970-01-01 12:34:00 UTC--1970-01-02 01:25:00 UTC # Expected

## __ To return `start` and `end` as list __
start <- hms::parse_hm("22:15")
end <- hms::parse_hm("00:01")
assign_date(start, end, return = "list")
#> $start # Expected
#> [1] "1970-01-01 22:15:00 UTC" # Expected
#> # Expected
#> $end # Expected
#> [1] "1970-01-02 00:01:00 UTC" # Expected

## __ To return only `start` or `end` __
start <- lubridate::parse_date_time("01:10:00", "HMS")
end <- lubridate::parse_date_time("11:45:00", "HMS")
assign_date(start, end, return = "start")
#> [1] "1970-01-01 01:10:00 UTC" # Expected
assign_date(start, end, return = "end")
#> [1] "1970-01-01 11:45:00 UTC" # Expected

## __ To assign a 24h interval to ambiguities __
start <- lubridate::as_datetime("1985-01-15 12:00:00")
end <- lubridate::as_datetime("2020-09-10 12:00:00")
assign_date(start, end, ambiguity = 24)
#> [1] 1970-01-01 12:00:00 UTC--1970-01-02 12:00:00 UTC # Expected
}
\seealso{
Other utility functions: 
\code{\link{convert}()},
\code{\link{pretty_mctq}()},
\code{\link{qplot_walk}()},
\code{\link{random_mctq}()},
\code{\link{raw_data}()},
\code{\link{round_time}()},
\code{\link{shortest_interval}()},
\code{\link{sum_time}()}
}
\concept{utility functions}
