% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sum_time.R
\name{sum_time}
\alias{sum_time}
\title{Sum time objects}
\usage{
sum_time(
  ...,
  class = "hms",
  circular = FALSE,
  vectorize = FALSE,
  na.rm = FALSE
)
}
\arguments{
\item{...}{Objects belonging to one of the following classes: \code{Duration},
\code{Period}, \code{difftime}, \code{hms}, \code{POSIXct}, \code{POSIXlt}, or \code{Interval}.}

\item{class}{(optional) a string indicating the output class (default:
\code{"hms"}).}

\item{circular}{(optional) a \code{logical} value indicating whether the sum
should be made in a circular time frame of 24 hours (clock hours) (default:
\code{FALSE}).}

\item{vectorize}{(optional) a \code{logical} value indicating if the function must
operate in a vectorized fashion (default: \code{FALSE}).}

\item{na.rm}{(optional) a \code{logical} value indicating if the function must
remove \code{NA} values while performing the sum (default: \code{FALSE}).}
}
\value{
\itemize{
\item If \code{circular = TRUE} and \code{vectorize = FALSE}, an object of
the indicated class in \code{class} (default: \code{"hms"}) with the sum of the time
from objects in \code{...} in a circular time frame of 24 hours.
\item If \code{circular = FALSE} and \code{vectorize = FALSE}, an
object of the indicated class in \code{class} (default: \code{"hms"}) with a
linear sum of the time from objects in \code{...}.
\item If \code{circular = TRUE} and \code{vectorize = TRUE}, an object of the indicated
class in \code{class} (default: \code{"hms"}) with a vectorized sum of the time from
objects in \code{...} in a circular time frame of 24 hours.
\item If \code{circular = FALSE} and \code{vectorize = TRUE}, an object of the
indicated class in \code{class} (default: \code{"hms"}) with a vectorized and
linear sum of the time from objects in \code{...}.
}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#maturing}{\figure{lifecycle-maturing.svg}{options: alt='[Maturing]'}}}{\strong{[Maturing]}}

\code{sum_time()} returns the sum of the time from different kinds of date/time
objects.

This function supports vectorized operations and can also be set to work with
a circular time frame of 24 hours.
}
\details{
\subsection{\code{class} argument}{

\code{sum_time()} is integrated with \code{\link[=convert]{convert()}}. That way you can choose
what class of object you prefer as output.

Valid \code{class} values are: \code{"character"}, \code{"integer"}, \code{"double"},
\code{"numeric"}, \code{"Duration"}, \code{"Period"}, \code{"difftime"}, and \code{"hms"} (case
insensitive).
}

\subsection{\code{vectorize} argument}{

If \code{vectorize = FALSE} (default), \code{sum_time} will combine and sum all time
values in \code{...}. That is, \code{sum_time(c(x, y), z)} will have the same
output as \code{sum_time(x, y, z)}.

However, if \code{vectorize = TRUE}, \code{sum_time()} will require that all objects in
\code{...} have the same length, and will perform a paired sum between elements.
That is, \code{sum_time(c(x, y), c(w, z))} will return a vector like
\code{c(sum_time(x, w), sum_time(y, z))}.
}

\subsection{\code{POSIXt} objects}{

\code{POSIXt} values in \code{...} will be stripped of their dates. Only the time will
be considered.
}

\subsection{\code{Period} objects}{

\code{Period} objects are a special time of object developed by the
\link[lubridate:lubridate-package]{lubridate} team that represents "human units",
ignoring possible time irregularities. That is to say that 1 day as \code{Period}
will always represent 1 day in the timeline. \code{sum_time()} ignores that
property of \code{Period} objects, treating them like objects of class \code{Duration}.
}

\subsection{Timeline irregularities}{

This function does not take into account timeline irregularities (\emph{e.g.},
leap years, DST, leap seconds). This may not be an issue for most people, but
it must be considered when doing time arithmetic.
}
}
\examples{
## __ Linear non-vectorized sum __
x <- c(as.POSIXct("2020-01-01 15:00:00"), as.POSIXct("1999-05-04 17:30:00"))
y <- lubridate::as.interval(lubridate::dhours(7), as.Date("1970-05-08"))
sum_time(x, y, class = "duration")
#> [1] "142200s (~1.65 days)" # Expected

## __ Non-vectorized sum in a circular time frame of 24 hours __
x <- c(lubridate::hours(25), lubridate::dhours(5), lubridate::minutes(50))
sum_time(x, circular = TRUE)
#> 06:50:00 # Expected

x <- c(hms::parse_hm("00:15"), hms::parse_hm("02:30"), hms::as_hms(NA))
sum_time(x, circular = TRUE)
#> NA # Expected
sum_time(x, circular = TRUE, na.rm = TRUE)
#> 02:45:00 # Expected

## __ Linear vectorized sum __
x <- c(lubridate::dhours(6), NA)
y <- c(hms::parse_hm("23:00"), hms::parse_hm("10:00"))
sum_time(x, y, vectorize = TRUE)
#> 29:00:00 # Expected
#>       NA # Expected
sum_time(x, y, vectorize = TRUE, na.rm = TRUE)
#> 29:00:00 # Expected
#> 10:00:00 # Expected

## __ Vectorized sum in a circular time frame of 24 hours __
x <- c(lubridate::dhours(6), NA)
y <- c(hms::parse_hm("23:00"), hms::parse_hm("10:00"))
sum_time(x, y, circular = TRUE, vectorize = TRUE)
#> 05:00:00 # Expected
#>       NA # Expected
sum_time(x, y, circular = TRUE, vectorize = TRUE, na.rm = TRUE)
#> 05:00:00 # Expected
#> 10:00:00 # Expected
}
\seealso{
Other utility functions: 
\code{\link{assign_date}()},
\code{\link{convert}()},
\code{\link{pretty_mctq}()},
\code{\link{qplot_walk}()},
\code{\link{random_mctq}()},
\code{\link{raw_data}()},
\code{\link{round_time}()},
\code{\link{shortest_interval}()}
}
\concept{utility functions}
