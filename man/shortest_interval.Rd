% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/shortest_interval.R
\name{shortest_interval}
\alias{shortest_interval}
\alias{longer_interval}
\title{Find the shortest interval between two hours}
\usage{
shortest_interval(x, y, class = "hms", inverse = FALSE, quiet = FALSE)

longer_interval(x, y, class = "hms", quiet = FALSE)
}
\arguments{
\item{x, y}{A \code{hms} or \code{POSIXt} object.}

\item{class}{(optional) a string indicating the object class of the output
(default: \code{"hms"}).}

\item{inverse}{(optional) a \code{logical} value indicating if the function must
return a inverse output, \emph{i.e} the longer interval between \code{x} and \code{y}.}

\item{quiet}{(optional) a \code{logical} value indicating if warnings or messages
must be suppressed (default: \code{FALSE}).}
}
\value{
An object, of class indicated on \code{class}, with the shortest or
longer interval (if \code{inverse = TRUE} or \code{longer_interval()} is used)
between \code{x} and \code{y}.
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#maturing}{\figure{lifecycle-maturing.svg}{options: alt='[Maturing]'}}}{\strong{[Maturing]}}

\code{shortest_interval()} finds and return the shortest interval between two
\code{hms} or \code{POSIXt} objects hours.

\code{longer_interval()} do the inverse of \code{shortest_interval()}, \emph{i.e}
finds the longer interval between two hours. It's just a wrapper for
\code{shortest_interval(x, y, class, inverse = TRUE)}.
}
\details{
\subsection{The two intervals problem}{

Given two hours, \code{x} and \code{y}, in a two-day timeline, without date references,
there will be always two possible intervals between them, as illustrated
below.

To figure out what interval is the  shortest or the longer,
\code{shortest_interval()} checks two scenarios: 1. When \code{x} comes before \code{y}; and
2. when \code{x} comes after \code{y}. This only works if \code{x} value is smaller than
\code{y}, therefore, the function will make sure to swap \code{x} and \code{y} values if the
latter assumption is not true.

Because \code{shortest_interval()} objective is to find the shortest interval, if
\code{x} and \code{y} are equal, the shortest interval will have a length of 0 hours,
resulting in a interval from \code{x} to \code{x}. But, if \code{inverse = TRUE} or
\code{longer_interval()} is used instead, the latter condition will return a
interval with 24 hours of length (from \code{x} to \code{x} + 1 day).

In cases when \code{x} and \code{y} distance themselves by 12 hours, there will be no
shortest or longer interval (they are equal). In this cases,
\code{shortest_interval()} and \code{longer_interval()} will return the same value
(a interval of 12 hours).\preformatted{             day 1                        day 2
     x                  y         x                  y
   06:00              22:00     06:00              22:00
-----|------------------|---------|------------------|----->
              16h           8h             16h
          longer int.  shortest int.   longer int.

              day 1                      day 2
     y                   x       y                   x
   13:00               08:00   13:00               08:00
-----|-------------------|-------|-------------------|----->
              19h           5h            19h
          longer int.  shortest int.  longer int.

    x,y             x,y             x,y             x,y
     x               y               x               y
   10:00           10:00           10:00           10:00
-----|---------------|---------------|---------------|----->
    0h              0h              0h              0h
            24h             24h             24h

              day 1                      day 2
     y               x               y               x
   12:00           00:00           12:00           00:00
-----|---------------|---------------|---------------|----->
            12h             12h             12h
}
}

\subsection{Class requirements}{

The \code{mctq} package works with a set of object classes specially created to
hold time values. These classes can be found in the \link[hms:hms-package]{hms}
and \link[lubridate:lubridate-package]{lubridate} packages. If your data do not
conform to the object classes required, you can use \code{\link[=convert]{convert()}} to
convert it.
}

\subsection{\code{class} argument}{

\code{shortest_interval()} is integrated with \code{\link[=convert]{convert()}}. That way you
can choose what class of object your prefer as output.

Valid \code{class} values are: \code{"Duration"}, \code{"Period"}, \code{"difftime"}, \code{"hms"},
and \code{"Interval"} (case insensitive).
}

\subsection{\code{POSIXt} objects}{

\code{POSIXt} objects passed as argument to \code{x} or \code{y} will be strip of their
dates. Only the hours will be considered.
}
}
\examples{
## __ Scalar example __
x <- hms::parse_hm("23:00")
y <- hms::parse_hm("01:00")
shortest_interval(x, y)
#> 02:00:00 # Expected

x <- lubridate::as_datetime("1985-01-15 12:00:00")
y <- lubridate::as_datetime("2020-09-10 12:00:00")
shortest_interval(x, y)
#> 00:00:00 # Expected

## __ Vector example __
x <- c(hms::parse_hm("15:30"), hms::parse_hm("21:30"))
y <- c(hms::parse_hm("19:30"), hms::parse_hm("04:00"))
shortest_interval(x, y)
#> 04:00:00 # Expected
#> 06:30:00 # Expected

## __ Finding the longer interval between two hours __
x <- lubridate::parse_date_time("01:10:00", "HMS")
y <- lubridate::parse_date_time("11:45:00", "HMS")
shortest_interval(x, y, inverse = TRUE)
#> 13:25:00 # Expected

x <- lubridate::as_datetime("1915-02-14 05:00:00")
y <- lubridate::as_datetime("1970-07-01 05:00:00")
longer_interval(x, y)
#> 24:00:00 # Expected

## __ Changing the output object class __
x <- as.POSIXct("1988-10-05 02:00:00")
y <- as.POSIXlt("2100-05-07 13:30:00")
shortest_interval(x, y, "Interval")
#> [1] 1970-01-01 02:00:00 UTC--1970-01-01 13:30:00 UTC # Expected
longer_interval(x, y, "Duration")
#> [1] "45000s (~12.5 hours)" # Expected
shortest_interval(x, y, "Period")
#> [1] "11H 30M 0S" # Expected
longer_interval(x, y, "hms")
#> 12:30:00" # Expected
}
\seealso{
Other utility functions: 
\code{\link{assign_date}()},
\code{\link{convert}()},
\code{\link{pretty_mctq}()},
\code{\link{qplot_walk}()},
\code{\link{random_mctq}()},
\code{\link{raw_data}()},
\code{\link{round_time}()},
\code{\link{sum_time}()}
}
\concept{utility functions}
