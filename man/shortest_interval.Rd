% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/shortest_interval.R
\name{shortest_interval}
\alias{shortest_interval}
\alias{longer_interval}
\title{Find the shortest interval between two hours}
\usage{
shortest_interval(x, y, class = base::class(x)[1], inverse = FALSE)

longer_interval(x, y, class = base::class(x)[1])
}
\arguments{
\item{x, y}{A \code{hms} or \code{POSIXt} object.}

\item{class}{(optional) a string indicating the object class of the output
(default: \code{class(x)[1]}).}

\item{inverse}{(optional) a \code{logical} value indicating if the function must
return a inverse output, \emph{i.e} the longer interval between \code{x} and \code{y}.}
}
\value{
A R object, of class indicated on \code{class}, with the shortest or
longer interval (if \code{inverse = TRUE} or \code{longer_interval()} is used)
between \code{x} and \code{y}.
}
\description{
\ifelse{html}{\out{<a href='https://www.tidyverse.org/lifecycle/#experimental'><img src='figures/lifecycle-experimental.svg' alt='Experimental lifecycle'></a>}}{\strong{Experimental}}

\code{shortest_interval()} finds and return the shortest interval between two
\code{hms} or \code{POSIXt} objects hours. This is useful for time arithmetic, because
there's always two possible intervals between two hour values with no date
reference.

\code{longer_interval()} do the inverse of \code{shortest_interval()}, \emph{i.e}
finds the longer interval between two hours. It's just a wrapper for
\code{shortest_interval(x, y, class, inverse = TRUE)}.
}
\details{
\subsection{The two intervals problem}{

Given two hours, \code{x} and \code{y}, without date references, there will be always
two possible intervals between them, as illustrated below.

To figure out what interval is the  shortest or longer, \code{shortest_interval()}
checks two scenarios: 1. When \code{x} comes before \code{y}; and 2. when \code{x} comes
after \code{y}. This only works if \code{x} value is smaller than \code{y}, therefore, the
function will make sure to swap \code{x} and \code{y} values if the latter assumption
is not true.

Because \code{shortest_interval()} objective is to find the shortest interval, if
\code{x} and \code{y} are equal, the shortest interval will have a length of 0 hours,
resulting in a interval from \code{x} to \code{x}. But, if \code{inverse = TRUE} or
\code{longer_interval()} is use instead, the latter condition will return a
interval with 24 hours of length (from \code{x} to \code{x} + 1 day).

Note that this function assumes a limit of 24h for longer intervals.\preformatted{             day 1                        day 2
     x                  y         x                  y
   06:00              22:00     06:00              22:00
-----|------------------|---------|------------------|----->
              16h           8h             16h
          longer int.   shorter int.    longer int.

              day 1                      day 2
     y                   x       y                   x
   13:00               08:00   13:00               08:00
-----|-------------------|-------|-------------------|----->
              19h           5h            19h
          longer int.   shorter int.   longer int.

    x,y             x,y             x,y             x,y
     x               y               x               y
   10:00           10:00           10:00           10:00
-----|---------------|---------------|---------------|----->
    0h              0h              0h              0h
            24h             24h             24h
}
}

\subsection{\code{class} argument}{

\code{shortest_interval()} is integrated with \code{\link[=convert]{convert()}}. That way you
can choose what class of object your prefer as output.

Valid \code{class} values are: \code{"Duration"}, \code{"Period"}, \code{"hms"}, \code{"POSIXct"},
\code{"POSIXlt"}, and \code{"Interval"} (case insensitive).
}

\subsection{\code{POSIXt} objects}{

\code{POSIXt} values passed as argument to \code{x} or \code{y} will be strip of their
dates. Only the hours will be considered.
}

\subsection{\code{NA} values}{

\code{shortest_interval()} will return \code{NA} if \code{x} or \code{y} are \code{NA}.
}
}
\examples{
## __ Finding the shortest interval between two hour values __
x <- hms::parse_hms("23:00:00")
y <- hms::parse_hms("01:00:00")
shortest_interval(x, y)
#> 02:00:00 # Expected

x <- lubridate::as_datetime("1985-01-15 12:00:00")
y <- lubridate::as_datetime("2020-09-10 12:00:00")
shortest_interval(x, y, "hms")
#> 00:00:00 # Expected

## __ Finding the longer interval between two hour values __
x <- lubridate::parse_date_time("01:10:00", "HMS")
y <- lubridate::parse_date_time("11:45:00", "HMS")
longer_interval(x, y, "hms")
#> 13:25:00 # Expected

x <- lubridate::as_datetime("1915-02-14 05:00:00")
y <- lubridate::as_datetime("1970-07-01 05:00:00")
longer_interval(x, y, "hms")
#> 24:00:00 # Expected

## __ Changing the output object class __
x <- as.POSIXct("1988-10-05 02:00:00")
y <- as.POSIXlt("2100-05-07 13:30:00")
shortest_interval(x, y, "Interval")
#> [1] 1970-01-01 02:00:00 UTC--1970-01-01 13:30:00 UTC # Expected

longer_interval(x, y, "Duration")
#> [1] "45000s (~12.5 hours)" # Expected
shortest_interval(x, y, "Period")
#> [1] "11H 30M 0S" # Expected
longer_interval(x, y, "POSIXlt")
#> [1] "1970-01-01 12:30:00 UTC" # Expected
}
\seealso{
Other utility functions: 
\code{\link{assign_date}()},
\code{\link{convert}()},
\code{\link{pretty_mctq}()},
\code{\link{qplot_walk}()},
\code{\link{random_mctq}()},
\code{\link{round_time}()},
\code{\link{sum_time}()}
}
\concept{utility functions}
