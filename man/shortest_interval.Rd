% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/shortest_interval.R
\name{shortest_interval}
\alias{shortest_interval}
\alias{longer_interval}
\title{Find the shortest interval between two hours}
\usage{
shortest_interval(x, y, class = "hms", inverse = FALSE)

longer_interval(x, y, class = "hms")
}
\arguments{
\item{x, y}{A \code{hms} or \code{POSIXt} vector.}

\item{class}{A string indicating the object class of the output.}

\item{inverse}{A logical value indicating if the function must return the
inverse output, \emph{i.e} the longer interval between \code{x} and \code{y}.}
}
\description{
\code{shortest_interval()} finds the shortest interval between two \code{hms} or
\code{POSIXt} objects. This is useful for linear time arithmetic, because there
always be two possible intervals between two hour values with no date
reference.
}
\details{
\subsection{Two intervals problem}{

Given two hours, \code{x} and \code{y}, without date references, there always will be
two possible intervals between them, as illustrated below.

To figure out what interval is the  shortest or longer, \code{shortest_interval()}
checks two scenarios: 1. When \code{x} comes before \code{y}; and 2. when \code{x}
comes after \code{y}. This only works if \code{x} value is smaller than \code{y}. This
function will make sure to swap \code{x} and \code{y} values if the latter assumption
is not true.

Because \code{shortest_interval()} objective is to find the shortest interval, if
\code{x} and \code{y} are equal, the shortest interval will always have a length of 0h.
But, if \code{inverse = TRUE} or \code{longer_interval()} is use instead, the latter
condition will return a interval of 24h of length.\preformatted{             day 1                        day 2
     x                  y         x                  y
   06:00              22:00     06:00              22:00
-----|------------------|---------|------------------|----->
              16h           8h             16h
           2nd int.      1st int.        2nd int.

              day 1                      day 2
     y                   x       y                   x
   13:00               08:00   13:00               08:00
-----|-------------------|-------|-------------------|----->
              19h           5h            19h
            2nd int.     1st int.       2nd int.

    x,y            x,y            x,y            x,y
   10:00          10:00          10:00          10:00
-----|---------------|---------------|---------------|----->
    0h              0h              0h              0h
            24h             24h             24h
}
}

\subsection{\code{class} argument}{

\code{shortest_interval()} is integrated with \code{\link[=convert_to]{convert_to()}}. That way you
can choose what class of object will prefer for output.

Valid \code{class} values are: \code{"Duration"}, \code{"Period"}, \code{"hms"}, \code{"POSIXct"},
\code{"POSIXlt"}, and \code{"Interval"} (case insensitive).
}

\subsection{\code{POSIXt} objects}{

\code{POSIXt} values passed as argument to \code{x} or \code{y} will be strip of their
dates. Only the hours will be considered.
}

\subsection{\code{longer_interval()} function}{

\code{longer_interval()} do the inverse of \code{shortest_interval()}, \emph{i.e}
finds the longer interval between two hours. It's just a wrapper for
\code{shortest_interval(x, y, class, inverse = TRUE)}.
}
}
\examples{
x <- hms::parse_hms("23:00:00")
y <- hms::parse_hms("01:00:00")
shortest_interval(x, y)
#> 02:00:00 # Expected
longer_interval(x, y)
#> 22:00:00 # Expected
shortest_interval(x, y, "Interval")
#> [1] 0000-01-01 23:00:00 UTC--0000-01-02 01:00:00 UTC # Expected
longer_interval(x, y, "Interval")
#> [1] 0000-01-01 01:00:00 UTC--0000-01-01 23:00:00 UTC # Expected
}
\concept{Time arithmetic}
